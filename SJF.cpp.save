#include <iostream>
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <chrono>
using namespace std;

// Helper function: return a sorted vector by value
vector<pair<int, int>> getSorted(const unordered_map<int,int>& processes) {
    vector<pair<int, int>> vec(processes.begin(), processes.end());
    sort(vec.begin(), vec.end(), [](auto &a, auto &b) {
        return a.second < b.second;
    });
    return vec;
}

// Calculate waiting time from sorted vector
double waitingTime(const vector<pair<int, int>>& vec){
    double totalWait = 0.0;
    double cumulative = 0.0;
    // waiting time for each process (except the first)
    for (int i = 0; i < vec.size(); i++) {
        totalWait += cumulative;   // add the time this process had to wait
        cumulative += vec[i].second; // update cumulative burst time
    }
    // exclude the dummy "p0" if you don't want it in avg
    return totalWait / (vec.size() - 1);
}

// Calculate turn around time from sorted vector
double turnaround(const vector<pair<int, int>>& vec) {
    double totalTAT = 0.0;
    double cumulative = 0.0;
    
    for (int i = 0; i < vec.size(); i++) {
        cumulative += vec[i].second; // completion time
        totalTAT += cumulative;      // turnaround time = completion time (assuming arrival time = 0)
    }
    // exclude the dummy "p1" in avg
    return totalTAT / (vec.size() - 1);
}

// Prints processes and accumulates step by step
void proc(unordered_map<int, int>& processes){

    int burstTime;
    int time = 1;
 
    cout << "Enter burstTime (enter 0 to stop):" << endl;
    while (cin >> burstTime && burstTime != 0) {
    processes[time] = burstTime;
        cout << "Process " << time << ": " << burstTime << endl;
         ++time;
    }

    int sum = 0;

    cout << "\nAll processes stored in hash table:\n";
    for (const auto& pair : processes) {
        cout << "Process " << pair.first << ": " << pair.second << endl;
    }
    
    // get sorted processes
    auto vec = getSorted(processes);
    
    // Print sorted
    f
    
    // Step by step accumulation (completion times)
    cout << "\nCompletion times: ";
    int cumulative = 0;
    for (int i = 0; i < vec.size(); i++) {
        cumulative += vec[i].second;
        cout << cumulative << " ";
    }
    cout << endl;
    
    // Print waiting time & turnaround
    cout << "Average waiting time: " << waitingTime(vec) << "m/s" << endl;
    cout << "Average turnaround time: " << turnaround(vec) << "m/s" << endl;
}

int main() {
    unordered_map<int, int> processes;
    auto start = chrono::high_resolution_clock::now();
	
    proc(processes);  // this will also print waiting time
    auto end = chrono::high_resolution_clock::now();
	// Calculate duration in microseconds
    auto duration = chrono::duration_cast<chrono::microseconds>(end - start);

    // Print the execution time
    std::cout << "Execution time: " << duration.count() << " microseconds" << std::endl;

    return 0;
}

